From 7bee53b54e5a73a6f236859962889b9ecf7ffc9b Mon Sep 17 00:00:00 2001
From: Davide Baldo <davide.baldo@zextras.com>
Date: Wed, 27 Apr 2022 18:03:39 +0200
Subject: [PATCH] initial websocket support

---
 agent/config/builder.go                       |   1 +
 agent/config/config.go                        |   3 +
 agent/config/testdata/full-config.hcl         |   1 +
 agent/config/testdata/full-config.json        |   3 +-
 agent/consul/config_endpoint.go               |   5 +
 agent/consul/config_endpoint_test.go          | 118 +++++++++++--
 agent/consul/discoverychain/compile.go        |  60 +++++--
 agent/consul/state/catalog.go                 |   1 +
 agent/proxycfg/snapshot.go                    |   8 +-
 agent/proxycfg/state.go                       |   2 +-
 agent/proxycfg/testing.go                     |   2 +-
 agent/structs/config_entry.go                 |  14 ++
 agent/structs/config_entry_gateways.go        |   8 +
 agent/structs/connect_proxy_config.go         |   5 +
 agent/structs/discovery_chain.go              |   7 +
 agent/xds/config.go                           |   5 +
 agent/xds/listeners.go                        |  41 +++--
 agent/xds/listeners_test.go                   |   9 +
 ...tp-public-listener-websocket.latest.golden | 156 ++++++++++++++++++
 ...ateway-service-subsets.envoy-1-20-x.golden |  11 +-
 .../terminating-gateway.envoy-1-20-x.golden   |   7 +-
 api/config_entry.go                           |   6 +
 22 files changed, 423 insertions(+), 50 deletions(-)
 create mode 100644 agent/xds/testdata/listeners/http-public-listener-websocket.latest.golden

diff --git a/agent/config/builder.go b/agent/config/builder.go
index 8c199950045..779e1369530 100644
--- a/agent/config/builder.go
+++ b/agent/config/builder.go
@@ -1788,6 +1788,7 @@ func (b *builder) pathsVal(v []ExposePath) []structs.ExposePath {
 			Path:          stringVal(p.Path),
 			LocalPathPort: intVal(p.LocalPathPort),
 			Protocol:      stringVal(p.Protocol),
+			Websocket:     boolVal(p.Websocket),
 		}
 	}
 	return paths
diff --git a/agent/config/config.go b/agent/config/config.go
index 0c503c38d6e..6b1fa1d1a17 100644
--- a/agent/config/config.go
+++ b/agent/config/config.go
@@ -579,6 +579,9 @@ type ExposePath struct {
 	// Protocol describes the upstream's service protocol.
 	Protocol *string `mapstructure:"protocol"`
 
+	// Websocket whether websocket upgrade is supported.
+	Websocket *bool `mapstructure:"websocket"`
+
 	// LocalPathPort is the port that the service is listening on for the given path.
 	LocalPathPort *int `mapstructure:"local_path_port"`
 }
diff --git a/agent/config/testdata/full-config.hcl b/agent/config/testdata/full-config.hcl
index 0d75e017566..81b3d8ff7ab 100644
--- a/agent/config/testdata/full-config.hcl
+++ b/agent/config/testdata/full-config.hcl
@@ -603,6 +603,7 @@ services = [
                         local_path_port = 8080
                         listener_port = 21500
                         protocol = "http"
+                        websocket = true
                     }
                 ]
             }
diff --git a/agent/config/testdata/full-config.json b/agent/config/testdata/full-config.json
index fbbea1cb2cd..0e6c15f0dc7 100644
--- a/agent/config/testdata/full-config.json
+++ b/agent/config/testdata/full-config.json
@@ -576,7 +576,8 @@
               "path": "/health",
               "local_path_port": 8080,
               "listener_port": 21500,
-              "protocol": "http"
+              "protocol": "http",
+              "websocket": true
             }
           ]
         },
diff --git a/agent/consul/config_endpoint.go b/agent/consul/config_endpoint.go
index dca6895c41c..3b70bd6290a 100644
--- a/agent/consul/config_endpoint.go
+++ b/agent/consul/config_endpoint.go
@@ -518,6 +518,7 @@ func (c *ConfigEntry) computeResolvedServiceConfig(
 	// blocking query, this function will be rerun and these state store lookups will both be current.
 	// We use the default enterprise meta to look up the global proxy defaults because they are not namespaced.
 	var proxyConfGlobalProtocol string
+	var proxyConfGlobalWebsocket bool
 	proxyConf := entries.GlobalProxy
 	if proxyConf != nil {
 		// Apply the proxy defaults to the sidecar's proxy config
@@ -570,6 +571,7 @@ func (c *ConfigEntry) computeResolvedServiceConfig(
 		if serviceConf.Mode != structs.ProxyModeDefault {
 			thisReply.Mode = serviceConf.Mode
 		}
+		thisReply.ProxyConfig["websocket"] = serviceConf.Websocket
 	}
 
 	// First collect all upstreams into a set of seen upstreams.
@@ -652,6 +654,9 @@ func (c *ConfigEntry) computeResolvedServiceConfig(
 			if upstreamSvcDefaults.Protocol != "" {
 				protocol = upstreamSvcDefaults.Protocol
 			}
+			resolvedCfg["websocket"] = upstreamSvcDefaults.Websocket
+		} else {
+			resolvedCfg["websocket"] = proxyConfGlobalWebsocket
 		}
 		if protocol != "" {
 			resolvedCfg["protocol"] = protocol
diff --git a/agent/consul/config_endpoint_test.go b/agent/consul/config_endpoint_test.go
index d47af99cab5..d719fc0201f 100644
--- a/agent/consul/config_endpoint_test.go
+++ b/agent/consul/config_endpoint_test.go
@@ -1070,12 +1070,14 @@ func TestConfigEntry_ResolveServiceConfig(t *testing.T) {
 
 	expected := structs.ServiceConfigResponse{
 		ProxyConfig: map[string]interface{}{
-			"foo":      int64(1),
-			"protocol": "http",
+			"foo":       int64(1),
+			"protocol":  "http",
+			"websocket": false,
 		},
 		UpstreamConfigs: map[string]map[string]interface{}{
 			"bar": {
-				"protocol": "grpc",
+				"protocol":  "grpc",
+				"websocket": false,
 			},
 		},
 		// Don't know what this is deterministically
@@ -1091,6 +1093,76 @@ func TestConfigEntry_ResolveServiceConfig(t *testing.T) {
 	require.Equal(map[string]interface{}{"foo": 1}, proxyConf.Config)
 }
 
+func TestConfigEntry_ResolveServiceConfig_With_Websocket(t *testing.T) {
+	if testing.Short() {
+		t.Skip("too slow for testing.Short")
+	}
+
+	t.Parallel()
+
+	dir1, s1 := testServer(t)
+	defer os.RemoveAll(dir1)
+	defer s1.Shutdown()
+	codec := rpcClient(t, s1)
+	defer codec.Close()
+
+	// Create a dummy proxy/service config in the state store to look up.
+	state := s1.fsm.State()
+	require.NoError(t, state.EnsureConfigEntry(2, &structs.ServiceConfigEntry{
+		Kind:      structs.ServiceDefaults,
+		Name:      "foo",
+		Protocol:  "http",
+		Websocket: true,
+	}))
+	require.NoError(t, state.EnsureConfigEntry(2, &structs.ServiceConfigEntry{
+		Kind:      structs.ServiceDefaults,
+		Name:      "bar",
+		Protocol:  "grpc",
+		Websocket: false,
+	}))
+
+	//check that webrtc is accepted only with http
+	require.Error(t, state.EnsureConfigEntry(2, &structs.ServiceConfigEntry{
+		Kind:      structs.ServiceDefaults,
+		Name:      "bar",
+		Protocol:  "grpc",
+		Websocket: true,
+	}))
+
+	args := structs.ServiceConfigRequest{
+		Name:       "foo",
+		Datacenter: s1.config.Datacenter,
+	}
+	var out structs.ServiceConfigResponse
+	require.NoError(t, msgpackrpc.CallWithCodec(codec, "ConfigEntry.ResolveServiceConfig", &args, &out))
+
+	expected := structs.ServiceConfigResponse{
+		ProxyConfig: map[string]interface{}{
+			"protocol":  "http",
+			"websocket": true,
+		},
+		// Don't know what this is deterministically
+		QueryMeta: out.QueryMeta,
+	}
+	require.Equal(t, expected, out)
+
+	args = structs.ServiceConfigRequest{
+		Name:       "bar",
+		Datacenter: s1.config.Datacenter,
+	}
+	require.NoError(t, msgpackrpc.CallWithCodec(codec, "ConfigEntry.ResolveServiceConfig", &args, &out))
+
+	expected = structs.ServiceConfigResponse{
+		ProxyConfig: map[string]interface{}{
+			"protocol":  "grpc",
+			"websocket": false,
+		},
+		// Don't know what this is deterministically
+		QueryMeta: out.QueryMeta,
+	}
+	require.Equal(t, expected, out)
+}
+
 func TestConfigEntry_ResolveServiceConfig_TransparentProxy(t *testing.T) {
 	if testing.Short() {
 		t.Skip("too slow for testing.Short")
@@ -1676,8 +1748,9 @@ func TestConfigEntry_ResolveServiceConfig_Blocking(t *testing.T) {
 
 		expected := structs.ServiceConfigResponse{
 			ProxyConfig: map[string]interface{}{
-				"global":   int64(1),
-				"protocol": "grpc",
+				"global":    int64(1),
+				"protocol":  "grpc",
+				"websocket": false,
 			},
 			QueryMeta: out.QueryMeta,
 		}
@@ -1741,8 +1814,9 @@ func TestConfigEntry_ResolveServiceConfig_Blocking(t *testing.T) {
 
 		expected := structs.ServiceConfigResponse{
 			ProxyConfig: map[string]interface{}{
-				"global":   int64(1),
-				"protocol": "http",
+				"global":    int64(1),
+				"protocol":  "http",
+				"websocket": false,
 			},
 			QueryMeta: out.QueryMeta,
 		}
@@ -1785,7 +1859,8 @@ func TestConfigEntry_ResolveServiceConfig_Blocking(t *testing.T) {
 
 		expected := structs.ServiceConfigResponse{
 			ProxyConfig: map[string]interface{}{
-				"protocol": "http",
+				"protocol":  "http",
+				"websocket": false,
 			},
 			QueryMeta: out.QueryMeta,
 		}
@@ -1845,13 +1920,15 @@ func TestConfigEntry_ResolveServiceConfig_Upstreams_Blocking(t *testing.T) {
 
 		expected := structs.ServiceConfigResponse{
 			ProxyConfig: map[string]interface{}{
-				"protocol": "http",
+				"protocol":  "http",
+				"websocket": false,
 			},
 			UpstreamIDConfigs: []structs.OpaqueUpstreamConfig{
 				{
 					Upstream: structs.NewServiceID("bar", nil),
 					Config: map[string]interface{}{
-						"protocol": "http",
+						"protocol":  "http",
+						"websocket": false,
 					},
 				},
 			},
@@ -1906,7 +1983,8 @@ func TestConfigEntry_ResolveServiceConfig_Upstreams_Blocking(t *testing.T) {
 
 		expected := structs.ServiceConfigResponse{
 			ProxyConfig: map[string]interface{}{
-				"protocol": "http",
+				"protocol":  "http",
+				"websocket": false,
 			},
 			QueryMeta: out.QueryMeta, // don't care
 		}
@@ -1932,7 +2010,8 @@ func TestConfigEntry_ResolveServiceConfig_Upstreams_Blocking(t *testing.T) {
 
 		expected := structs.ServiceConfigResponse{
 			ProxyConfig: map[string]interface{}{
-				"protocol": "http",
+				"protocol":  "http",
+				"websocket": false,
 			},
 			QueryMeta: out.QueryMeta, // don't care
 		}
@@ -2044,20 +2123,25 @@ func TestConfigEntry_ResolveServiceConfig_UpstreamProxyDefaultsProtocol(t *testi
 
 	expected := structs.ServiceConfigResponse{
 		ProxyConfig: map[string]interface{}{
-			"protocol": "http",
+			"protocol":  "http",
+			"websocket": false,
 		},
 		UpstreamConfigs: map[string]map[string]interface{}{
 			"bar": {
-				"protocol": "http",
+				"protocol":  "http",
+				"websocket": false,
 			},
 			"other": {
-				"protocol": "http",
+				"protocol":  "http",
+				"websocket": false,
 			},
 			"dne": {
-				"protocol": "http",
+				"protocol":  "http",
+				"websocket": false,
 			},
 			"alreadyprotocol": {
-				"protocol": "grpc",
+				"protocol":  "grpc",
+				"websocket": false,
 			},
 		},
 		// Don't know what this is deterministically
diff --git a/agent/consul/discoverychain/compile.go b/agent/consul/discoverychain/compile.go
index ad8db97d81f..1ce4888b3e4 100644
--- a/agent/consul/discoverychain/compile.go
+++ b/agent/consul/discoverychain/compile.go
@@ -34,6 +34,11 @@ type CompileRequest struct {
 	// will not include Routers or Splitters.
 	OverrideProtocol string
 
+	// OverrideWebsocket allows usage of the websocket, this field is only allowed
+	// when protocol is http.
+	// If not present, the previously declared websocket state will be used.
+	OverrideWebsocket string
+
 	// OverrideConnectTimeout allows for the ConnectTimeout setting to be
 	// overridden for any resolver in the compiled chain.
 	OverrideConnectTimeout time.Duration
@@ -91,6 +96,7 @@ func Compile(req CompileRequest) (*structs.CompiledDiscoveryChain, error) {
 		useInDatacenter:        useInDatacenter,
 		overrideMeshGateway:    req.OverrideMeshGateway,
 		overrideProtocol:       req.OverrideProtocol,
+		overrideWebsocket:      req.OverrideWebsocket,
 		overrideConnectTimeout: req.OverrideConnectTimeout,
 		entries:                entries,
 
@@ -120,13 +126,16 @@ func Compile(req CompileRequest) (*structs.CompiledDiscoveryChain, error) {
 // compiler is a single-use struct for handling intermediate state necessary
 // for assembling a discovery chain from raw config entries.
 type compiler struct {
-	serviceName            string
-	evaluateInNamespace    string
-	evaluateInDatacenter   string
-	evaluateInTrustDomain  string
-	useInDatacenter        string
-	overrideMeshGateway    structs.MeshGatewayConfig
-	overrideProtocol       string
+	serviceName           string
+	evaluateInNamespace   string
+	evaluateInDatacenter  string
+	evaluateInTrustDomain string
+	useInDatacenter       string
+	overrideMeshGateway   structs.MeshGatewayConfig
+	overrideProtocol      string
+	// using string since we want a three-state, empty true and false
+	// to avoid overriding the value when omitted
+	overrideWebsocket      string
 	overrideConnectTimeout time.Duration
 
 	// config entries that are being compiled (will be mutated during compilation)
@@ -161,6 +170,12 @@ type compiler struct {
 	// This is an OUTPUT field.
 	protocol string
 
+	// websocket whether upgrade to websocket connection is supported.
+	// Only valid for http protocol.
+	//
+	// This is an OUTPUT field.
+	websocket bool
+
 	// startNode is computed inside of assembleChain()
 	//
 	// This is an OUTPUT field.
@@ -179,6 +194,7 @@ type compiler struct {
 type customizationMarkers struct {
 	MeshGateway    bool
 	Protocol       bool
+	Websocket      bool
 	ConnectTimeout bool
 }
 
@@ -212,17 +228,17 @@ func (c *compiler) recordNode(node *structs.DiscoveryGraphNode) {
 
 func (c *compiler) recordServiceProtocol(sid structs.ServiceID) error {
 	if serviceDefault := c.entries.GetService(sid); serviceDefault != nil {
-		return c.recordProtocol(sid, serviceDefault.Protocol)
+		return c.recordProtocol(sid, serviceDefault.Protocol, serviceDefault.Websocket)
 	}
 	if c.entries.GlobalProxy != nil {
 		var cfg proxyConfig
 		// Ignore errors and fallback on defaults if it does happen.
 		_ = mapstructure.WeakDecode(c.entries.GlobalProxy.Config, &cfg)
 		if cfg.Protocol != "" {
-			return c.recordProtocol(sid, cfg.Protocol)
+			return c.recordProtocol(sid, cfg.Protocol, false)
 		}
 	}
-	return c.recordProtocol(sid, "")
+	return c.recordProtocol(sid, "", false)
 }
 
 // proxyConfig is a snippet from agent/xds/config.go:ProxyConfig
@@ -230,7 +246,7 @@ type proxyConfig struct {
 	Protocol string `mapstructure:"protocol"`
 }
 
-func (c *compiler) recordProtocol(fromService structs.ServiceID, protocol string) error {
+func (c *compiler) recordProtocol(fromService structs.ServiceID, protocol string, websocket bool) error {
 	if protocol == "" {
 		protocol = "tcp"
 	} else {
@@ -238,6 +254,15 @@ func (c *compiler) recordProtocol(fromService structs.ServiceID, protocol string
 	}
 
 	if c.protocol == "" {
+		if websocket && protocol != "http" {
+			return &structs.ConfigEntryGraphError{
+				Message: fmt.Sprintf(
+					"discovery chain %q uses inconsistent protocols; service %q has %q but uses websocket",
+					c.serviceName, fromService.String(), protocol,
+				),
+			}
+		}
+		c.websocket = websocket
 		c.protocol = protocol
 	} else if c.protocol != protocol {
 		return &structs.ConfigEntryGraphError{
@@ -296,11 +321,20 @@ func (c *compiler) compile() (*structs.CompiledDiscoveryChain, error) {
 		}
 	}
 
+	if c.overrideWebsocket != "" {
+		parsedWebsocket := strings.ToLower(c.overrideWebsocket) == "true"
+		if parsedWebsocket != c.websocket {
+			c.websocket = parsedWebsocket
+			c.customizedBy.Websocket = true
+		}
+	}
+
 	var customizationHash string
 	if !c.customizedBy.IsZero() {
 		var customization struct {
 			OverrideMeshGateway    structs.MeshGatewayConfig
 			OverrideProtocol       string
+			OverrideWebsocket      string
 			OverrideConnectTimeout time.Duration
 		}
 
@@ -310,6 +344,9 @@ func (c *compiler) compile() (*structs.CompiledDiscoveryChain, error) {
 		if c.customizedBy.Protocol {
 			customization.OverrideProtocol = c.overrideProtocol
 		}
+		if c.customizedBy.Websocket {
+			customization.OverrideWebsocket = c.overrideWebsocket
+		}
 		if c.customizedBy.ConnectTimeout {
 			customization.OverrideConnectTimeout = c.overrideConnectTimeout
 		}
@@ -326,6 +363,7 @@ func (c *compiler) compile() (*structs.CompiledDiscoveryChain, error) {
 		Datacenter:        c.evaluateInDatacenter,
 		CustomizationHash: customizationHash,
 		Protocol:          c.protocol,
+		Websocket:         c.websocket,
 		StartNode:         c.startNode,
 		Nodes:             c.nodes,
 		Targets:           c.loadedTargets,
diff --git a/agent/consul/state/catalog.go b/agent/consul/state/catalog.go
index bca87a7c19e..e68619bb725 100644
--- a/agent/consul/state/catalog.go
+++ b/agent/consul/state/catalog.go
@@ -2511,6 +2511,7 @@ func ingressConfigGatewayServices(
 				Hosts:       service.Hosts,
 				Port:        listener.Port,
 				Protocol:    listener.Protocol,
+				Websocket:   listener.Websocket,
 			}
 
 			gatewayServices = append(gatewayServices, mapping)
diff --git a/agent/proxycfg/snapshot.go b/agent/proxycfg/snapshot.go
index cdfa9c5f119..46ca2939942 100644
--- a/agent/proxycfg/snapshot.go
+++ b/agent/proxycfg/snapshot.go
@@ -5,8 +5,9 @@ import (
 	"fmt"
 	"sort"
 
-	"github.com/hashicorp/consul/agent/structs"
 	"github.com/mitchellh/copystructure"
+
+	"github.com/hashicorp/consul/agent/structs"
 )
 
 // TODO(ingress): Can we think of a better for this bag of data?
@@ -336,8 +337,9 @@ func (c *configSnapshotIngressGateway) IsEmpty() bool {
 }
 
 type IngressListenerKey struct {
-	Protocol string
-	Port     int
+	Protocol  string
+	Websocket bool
+	Port      int
 }
 
 func (k *IngressListenerKey) RouteName() string {
diff --git a/agent/proxycfg/state.go b/agent/proxycfg/state.go
index a48ee135f4a..793498cd8e5 100644
--- a/agent/proxycfg/state.go
+++ b/agent/proxycfg/state.go
@@ -1763,7 +1763,7 @@ func (s *state) handleUpdateIngressGateway(u cache.UpdateEvent, snap *ConfigSnap
 
 			hosts = append(hosts, service.Hosts...)
 
-			id := IngressListenerKey{Protocol: service.Protocol, Port: service.Port}
+			id := IngressListenerKey{Protocol: service.Protocol, Websocket: service.Websocket, Port: service.Port}
 			upstreamsMap[id] = append(upstreamsMap[id], u)
 		}
 
diff --git a/agent/proxycfg/testing.go b/agent/proxycfg/testing.go
index 155c836c0a0..9feb722da39 100644
--- a/agent/proxycfg/testing.go
+++ b/agent/proxycfg/testing.go
@@ -1729,7 +1729,7 @@ func testConfigSnapshotIngressGateway(
 				t, variation, leaf, additionalEntries...,
 			),
 			Upstreams: map[IngressListenerKey]structs.Upstreams{
-				{protocol, 9191}: {
+				{protocol, false, 9191}: {
 					{
 						// We rely on this one having default type in a few tests...
 						DestinationName:  "db",
diff --git a/agent/structs/config_entry.go b/agent/structs/config_entry.go
index b2b55c287a6..8519263c753 100644
--- a/agent/structs/config_entry.go
+++ b/agent/structs/config_entry.go
@@ -93,6 +93,7 @@ type ServiceConfigEntry struct {
 	Kind             string
 	Name             string
 	Protocol         string
+	Websocket        bool
 	Mode             ProxyMode              `json:",omitempty"`
 	TransparentProxy TransparentProxyConfig `json:",omitempty" alias:"transparent_proxy"`
 	MeshGateway      MeshGatewayConfig      `json:",omitempty" alias:"mesh_gateway"`
@@ -142,6 +143,10 @@ func (e *ServiceConfigEntry) Normalize() error {
 
 	var validationErr error
 
+	if e.Websocket && e.Protocol != "http" {
+		validationErr = multierror.Append(validationErr, fmt.Errorf("error in default configurations provided for %s: websocket parameter was used for protocols different from http", e.Name))
+	}
+
 	if e.UpstreamConfig != nil {
 		for _, override := range e.UpstreamConfig.Overrides {
 			err := override.NormalizeWithName(&e.EnterpriseMeta)
@@ -171,6 +176,10 @@ func (e *ServiceConfigEntry) Validate() error {
 
 	validationErr := validateConfigEntryMeta(e.Meta)
 
+	if e.Websocket && e.Protocol != "http" {
+		validationErr = multierror.Append(validationErr, fmt.Errorf("error in default configurations provided for %s: websocket parameter was used for protocols different from http", e.Name))
+	}
+
 	if e.UpstreamConfig != nil {
 		for _, override := range e.UpstreamConfig.Overrides {
 			err := override.ValidateWithName()
@@ -700,6 +709,11 @@ type UpstreamConfig struct {
 	// routing etc.
 	Protocol string `json:",omitempty"`
 
+	// Websocket enable or disable the possibility to upgrade a http
+	// connection to a websocket. Makes sense only for http protocol,
+	// disabled by default.
+	Websocket bool `json:",omitempty"`
+
 	// ConnectTimeoutMs is the number of milliseconds to timeout making a new
 	// connection to this upstream. Defaults to 5000 (5 seconds) if not set.
 	ConnectTimeoutMs int `json:",omitempty" alias:"connect_timeout_ms"`
diff --git a/agent/structs/config_entry_gateways.go b/agent/structs/config_entry_gateways.go
index df0defa5458..0b5732cc05a 100644
--- a/agent/structs/config_entry_gateways.go
+++ b/agent/structs/config_entry_gateways.go
@@ -43,6 +43,11 @@ type IngressListener struct {
 	// current supported values are: (tcp | http | http2 | grpc).
 	Protocol string
 
+	// Websocket enable or disable the possibility to upgrade a http
+	// connection to a websocket. Makes sense only for http protocol,
+	// disabled by default.
+	Websocket bool `json:",omitempty"`
+
 	// Services declares the set of services to which the listener forwards
 	// traffic.
 	//
@@ -448,6 +453,7 @@ type GatewayService struct {
 	GatewayKind  ServiceKind
 	Port         int      `json:",omitempty"`
 	Protocol     string   `json:",omitempty"`
+	Websocket    bool     `json:",omitempty"`
 	Hosts        []string `json:",omitempty"`
 	CAFile       string   `json:",omitempty"`
 	CertFile     string   `json:",omitempty"`
@@ -485,6 +491,7 @@ func (g *GatewayService) IsSame(o *GatewayService) bool {
 		g.GatewayKind == o.GatewayKind &&
 		g.Port == o.Port &&
 		g.Protocol == o.Protocol &&
+		g.Websocket == o.Websocket &&
 		stringslice.Equal(g.Hosts, o.Hosts) &&
 		g.CAFile == o.CAFile &&
 		g.CertFile == o.CertFile &&
@@ -500,6 +507,7 @@ func (g *GatewayService) Clone() *GatewayService {
 		GatewayKind: g.GatewayKind,
 		Port:        g.Port,
 		Protocol:    g.Protocol,
+		Websocket:   g.Websocket,
 		// See https://github.com/go101/go101/wiki/How-to-efficiently-clone-a-slice%3F
 		Hosts:        append(g.Hosts[:0:0], g.Hosts...),
 		CAFile:       g.CAFile,
diff --git a/agent/structs/connect_proxy_config.go b/agent/structs/connect_proxy_config.go
index 3a2ac270d62..da71afd6ba4 100644
--- a/agent/structs/connect_proxy_config.go
+++ b/agent/structs/connect_proxy_config.go
@@ -588,6 +588,10 @@ type ExposePath struct {
 	// Valid values are "http" and "http2", defaults to "http"
 	Protocol string `json:",omitempty"`
 
+	// Websocket enable or disable the possibility to upgrade a http
+	// connection to a websocket, disabled by default.
+	Websocket bool `json:",omitempty"`
+
 	// ParsedFromCheck is set if this path was parsed from a registered check
 	ParsedFromCheck bool `json:",omitempty" alias:"parsed_from_check"`
 }
@@ -640,6 +644,7 @@ func (p *ExposePath) ToAPI() api.ExposePath {
 		Path:            p.Path,
 		LocalPathPort:   p.LocalPathPort,
 		Protocol:        p.Protocol,
+		Websocket:       p.Websocket,
 		ParsedFromCheck: p.ParsedFromCheck,
 	}
 }
diff --git a/agent/structs/discovery_chain.go b/agent/structs/discovery_chain.go
index 693891d88bc..c478c2be198 100644
--- a/agent/structs/discovery_chain.go
+++ b/agent/structs/discovery_chain.go
@@ -28,6 +28,13 @@ type CompiledDiscoveryChain struct {
 	// Protocol is the overall protocol shared by everything in the chain.
 	Protocol string `json:",omitempty"`
 
+	// Websocket whether websocket upgrade is supported.
+	Websocket bool
+
+	// ServiceMeta is the metadata from the underlying service-defaults config
+	// entry for the service named ServiceName.
+	ServiceMeta map[string]string `json:",omitempty"`
+
 	// StartNode is the first key into the Nodes map that should be followed
 	// when walking the discovery chain.
 	StartNode string `json:",omitempty"`
diff --git a/agent/xds/config.go b/agent/xds/config.go
index 020cefeb51d..f6c6cce5fa0 100644
--- a/agent/xds/config.go
+++ b/agent/xds/config.go
@@ -49,6 +49,11 @@ type ProxyConfig struct {
 	// pooling, tracing, routing etc.
 	Protocol string `mapstructure:"protocol"`
 
+	// Websocket enable or disable the possibility to upgrade a http
+	// connection to a websocket. Makes sense only for http protocol,
+	// disabled by default.
+	Websocket bool `mapstructure:"websocket"`
+
 	// BindAddress overrides the address the proxy's listener binds to. This
 	// enables proxies in network namespaces to bind to a different address
 	// than the host address.
diff --git a/agent/xds/listeners.go b/agent/xds/listeners.go
index efa55535c1c..51b85d826ca 100644
--- a/agent/xds/listeners.go
+++ b/agent/xds/listeners.go
@@ -130,6 +130,7 @@ func (s *ResourceGenerator) listenersFromSnapshotConnectProxy(cfgSnap *proxycfg.
 				clusterName: clusterName,
 				filterName:  filterName,
 				protocol:    cfg.Protocol,
+				websocket:   cfg.Websocket,
 				useRDS:      useRDS,
 			})
 			if err != nil {
@@ -155,6 +156,7 @@ func (s *ResourceGenerator) listenersFromSnapshotConnectProxy(cfgSnap *proxycfg.
 			clusterName: clusterName,
 			filterName:  filterName,
 			protocol:    cfg.Protocol,
+			websocket:   cfg.Websocket,
 			useRDS:      useRDS,
 		})
 		if err != nil {
@@ -279,6 +281,7 @@ func (s *ResourceGenerator) listenersFromSnapshotConnectProxy(cfgSnap *proxycfg.
 			filterName:  id,
 			routeName:   id,
 			protocol:    cfg.Protocol,
+			websocket:   cfg.Websocket,
 		})
 		if err != nil {
 			return nil, err
@@ -565,6 +568,7 @@ func (s *ResourceGenerator) makeIngressGatewayListeners(address string, cfgSnap
 				clusterName: clusterName,
 				filterName:  filterName,
 				protocol:    cfg.Protocol,
+				websocket:   cfg.Websocket,
 				tlsContext:  tlsContext,
 			})
 			if err != nil {
@@ -580,6 +584,7 @@ func (s *ResourceGenerator) makeIngressGatewayListeners(address string, cfgSnap
 			opts := listenerFilterOpts{
 				useRDS:          true,
 				protocol:        listenerKey.Protocol,
+				websocket:       listenerKey.Websocket,
 				filterName:      listenerKey.RouteName(),
 				routeName:       listenerKey.RouteName(),
 				cluster:         "",
@@ -909,6 +914,7 @@ func (s *ResourceGenerator) makeInboundListener(cfgSnap *proxycfg.ConfigSnapshot
 
 	filterOpts := listenerFilterOpts{
 		protocol:         cfg.Protocol,
+		websocket:        cfg.Websocket,
 		filterName:       name,
 		routeName:        name,
 		cluster:          LocalAppClusterName,
@@ -990,6 +996,7 @@ func (s *ResourceGenerator) makeExposedCheckListener(cfgSnap *proxycfg.ConfigSna
 	opts := listenerFilterOpts{
 		useRDS:          false,
 		protocol:        path.Protocol,
+		websocket:       path.Websocket,
 		filterName:      filterName,
 		routeName:       filterName,
 		cluster:         cluster,
@@ -1078,13 +1085,7 @@ func (s *ResourceGenerator) makeTerminatingGatewayListener(
 			)
 		}
 
-		clusterChain, err := s.makeFilterChainTerminatingGateway(
-			cfgSnap,
-			clusterName,
-			svc,
-			intentions,
-			cfg.Protocol,
-		)
+		clusterChain, err := s.makeFilterChainTerminatingGateway(cfgSnap, clusterName, svc, intentions, cfg.Protocol, false)
 		if err != nil {
 			return nil, fmt.Errorf("failed to make filter chain for cluster %q: %v", clusterName, err)
 		}
@@ -1102,6 +1103,7 @@ func (s *ResourceGenerator) makeTerminatingGatewayListener(
 					svc,
 					intentions,
 					cfg.Protocol,
+					cfg.Websocket,
 				)
 				if err != nil {
 					return nil, fmt.Errorf("failed to make filter chain for cluster %q: %v", subsetClusterName, err)
@@ -1138,13 +1140,7 @@ func (s *ResourceGenerator) makeTerminatingGatewayListener(
 	return l, nil
 }
 
-func (s *ResourceGenerator) makeFilterChainTerminatingGateway(
-	cfgSnap *proxycfg.ConfigSnapshot,
-	cluster string,
-	service structs.ServiceName,
-	intentions structs.Intentions,
-	protocol string,
-) (*envoy_listener_v3.FilterChain, error) {
+func (s *ResourceGenerator) makeFilterChainTerminatingGateway(cfgSnap *proxycfg.ConfigSnapshot, cluster string, service structs.ServiceName, intentions structs.Intentions, protocol string, websocket bool) (*envoy_listener_v3.FilterChain, error) {
 	tlsContext := &envoy_tls_v3.DownstreamTlsContext{
 		CommonTlsContext:         makeCommonTLSContextFromLeaf(cfgSnap, cfgSnap.TerminatingGateway.ServiceLeaves[service]),
 		RequireClientCertificate: &wrappers.BoolValue{Value: true},
@@ -1180,6 +1176,7 @@ func (s *ResourceGenerator) makeFilterChainTerminatingGateway(
 	// HTTP filter to do intention checks here instead.
 	opts := listenerFilterOpts{
 		protocol:   protocol,
+		websocket:  websocket,
 		filterName: fmt.Sprintf("%s.%s.%s", service.Name, service.NamespaceOrDefault(), cfgSnap.Datacenter),
 		routeName:  cluster, // Set cluster name for route config since each will have its own
 		cluster:    cluster,
@@ -1317,6 +1314,7 @@ type filterChainOpts struct {
 	clusterName string
 	filterName  string
 	protocol    string
+	websocket   bool
 	useRDS      bool
 	tlsContext  *envoy_tls_v3.DownstreamTlsContext
 }
@@ -1325,6 +1323,7 @@ func (s *ResourceGenerator) makeUpstreamFilterChain(opts filterChainOpts) (*envo
 	filter, err := makeListenerFilter(listenerFilterOpts{
 		useRDS:     opts.useRDS,
 		protocol:   opts.protocol,
+		websocket:  opts.websocket,
 		filterName: opts.filterName,
 		routeName:  opts.routeName,
 		cluster:    opts.clusterName,
@@ -1414,6 +1413,7 @@ func (s *ResourceGenerator) getAndModifyUpstreamConfigForListener(id string, u *
 type listenerFilterOpts struct {
 	useRDS           bool
 	protocol         string
+	websocket        bool
 	filterName       string
 	routeName        string
 	cluster          string
@@ -1471,6 +1471,18 @@ func makeStatPrefix(prefix, filterName string) string {
 }
 
 func makeHTTPFilter(opts listenerFilterOpts) (*envoy_listener_v3.Filter, error) {
+	var UpgradeConfigs []*envoy_http_v3.HttpConnectionManager_UpgradeConfig
+
+	if opts.protocol == "http" && opts.websocket {
+		UpgradeConfigs = []*envoy_http_v3.HttpConnectionManager_UpgradeConfig{
+			{
+				UpgradeType: "websocket",
+			},
+		}
+	} else {
+		UpgradeConfigs = []*envoy_http_v3.HttpConnectionManager_UpgradeConfig{}
+	}
+
 	cfg := &envoy_http_v3.HttpConnectionManager{
 		StatPrefix: makeStatPrefix(opts.statPrefix, opts.filterName),
 		CodecType:  envoy_http_v3.HttpConnectionManager_AUTO,
@@ -1485,6 +1497,7 @@ func makeHTTPFilter(opts listenerFilterOpts) (*envoy_listener_v3.Filter, error)
 			// sampled.
 			RandomSampling: &envoy_type_v3.Percent{Value: 0.0},
 		},
+		UpgradeConfigs: UpgradeConfigs,
 	}
 
 	if opts.useRDS {
diff --git a/agent/xds/listeners_test.go b/agent/xds/listeners_test.go
index 1d03796a83a..9f7194039e6 100644
--- a/agent/xds/listeners_test.go
+++ b/agent/xds/listeners_test.go
@@ -82,6 +82,15 @@ func TestListenersFromSnapshot(t *testing.T) {
 				snap.Proxy.Config["protocol"] = "http"
 			},
 		},
+		{
+			name: "http-public-listener-websocket",
+			create: func(t testinf.T) *proxycfg.ConfigSnapshot {
+				return proxycfg.TestConfigSnapshot(t, func(ns *structs.NodeService) {
+					ns.Proxy.Config["protocol"] = "http"
+					ns.Proxy.Config["websocket"] = "true"
+				}, nil)
+			},
+		},
 		{
 			name:   "http-listener-with-timeouts",
 			create: proxycfg.TestConfigSnapshot,
diff --git a/agent/xds/testdata/listeners/http-public-listener-websocket.latest.golden b/agent/xds/testdata/listeners/http-public-listener-websocket.latest.golden
new file mode 100644
index 00000000000..ae18be27296
--- /dev/null
+++ b/agent/xds/testdata/listeners/http-public-listener-websocket.latest.golden
@@ -0,0 +1,156 @@
+{
+  "versionInfo": "00000001",
+  "resources": [
+    {
+      "@type": "type.googleapis.com/envoy.config.listener.v3.Listener",
+      "name": "db:127.0.0.1:9191",
+      "address": {
+        "socketAddress": {
+          "address": "127.0.0.1",
+          "portValue": 9191
+        }
+      },
+      "filterChains": [
+        {
+          "filters": [
+            {
+              "name": "envoy.filters.network.tcp_proxy",
+              "typedConfig": {
+                "@type": "type.googleapis.com/envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy",
+                "statPrefix": "upstream.db.default.default.dc1",
+                "cluster": "db.default.dc1.internal.11111111-2222-3333-4444-555555555555.consul"
+              }
+            }
+          ]
+        }
+      ],
+      "trafficDirection": "OUTBOUND"
+    },
+    {
+      "@type": "type.googleapis.com/envoy.config.listener.v3.Listener",
+      "name": "prepared_query:geo-cache:127.10.10.10:8181",
+      "address": {
+        "socketAddress": {
+          "address": "127.10.10.10",
+          "portValue": 8181
+        }
+      },
+      "filterChains": [
+        {
+          "filters": [
+            {
+              "name": "envoy.filters.network.tcp_proxy",
+              "typedConfig": {
+                "@type": "type.googleapis.com/envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy",
+                "statPrefix": "upstream.prepared_query_geo-cache",
+                "cluster": "geo-cache.default.dc1.query.11111111-2222-3333-4444-555555555555.consul"
+              }
+            }
+          ]
+        }
+      ],
+      "trafficDirection": "OUTBOUND"
+    },
+    {
+      "@type": "type.googleapis.com/envoy.config.listener.v3.Listener",
+      "name": "public_listener:0.0.0.0:9999",
+      "address": {
+        "socketAddress": {
+          "address": "0.0.0.0",
+          "portValue": 9999
+        }
+      },
+      "filterChains": [
+        {
+          "filters": [
+            {
+              "name": "envoy.filters.network.http_connection_manager",
+              "typedConfig": {
+                "@type": "type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager",
+                "statPrefix": "public_listener",
+                "routeConfig": {
+                  "name": "public_listener",
+                  "virtualHosts": [
+                    {
+                      "name": "public_listener",
+                      "domains": [
+                        "*"
+                      ],
+                      "routes": [
+                        {
+                          "match": {
+                            "prefix": "/"
+                          },
+                          "route": {
+                            "cluster": "local_app"
+                          }
+                        }
+                      ]
+                    }
+                  ]
+                },
+                "httpFilters": [
+                  {
+                    "name": "envoy.filters.http.rbac",
+                    "typedConfig": {
+                      "@type": "type.googleapis.com/envoy.extensions.filters.http.rbac.v3.RBAC",
+                      "rules": {
+
+                      }
+                    }
+                  },
+                  {
+                    "name": "envoy.filters.http.router",
+                    "typedConfig": {
+                      "@type": "type.googleapis.com/envoy.extensions.filters.http.router.v3.Router"
+                    }
+                  }
+                ],
+                "tracing": {
+                  "randomSampling": {
+
+                  }
+                },
+                "upgradeConfigs": [
+                  {
+                    "upgradeType": "websocket"
+                  }
+                ]
+              }
+            }
+          ],
+          "transportSocket": {
+            "name": "tls",
+            "typedConfig": {
+              "@type": "type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext",
+              "commonTlsContext": {
+                "tlsParams": {
+
+                },
+                "tlsCertificates": [
+                  {
+                    "certificateChain": {
+                      "inlineString": "-----BEGIN CERTIFICATE-----\nMIICjDCCAjKgAwIBAgIIC5llxGV1gB8wCgYIKoZIzj0EAwIwFDESMBAGA1UEAxMJ\nVGVzdCBDQSAyMB4XDTE5MDMyMjEzNTgyNloXDTI5MDMyMjEzNTgyNlowDjEMMAoG\nA1UEAxMDd2ViMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEADPv1RHVNRfa2VKR\nAB16b6rZnEt7tuhaxCFpQXPj7M2omb0B9Favq5E0ivpNtv1QnFhxtPd7d5k4e+T7\nSkW1TaOCAXIwggFuMA4GA1UdDwEB/wQEAwIDuDAdBgNVHSUEFjAUBggrBgEFBQcD\nAgYIKwYBBQUHAwEwDAYDVR0TAQH/BAIwADBoBgNVHQ4EYQRfN2Q6MDc6ODc6M2E6\nNDA6MTk6NDc6YzM6NWE6YzA6YmE6NjI6ZGY6YWY6NGI6ZDQ6MDU6MjU6NzY6M2Q6\nNWE6OGQ6MTY6OGQ6Njc6NWU6MmU6YTA6MzQ6N2Q6ZGM6ZmYwagYDVR0jBGMwYYBf\nZDE6MTE6MTE6YWM6MmE6YmE6OTc6YjI6M2Y6YWM6N2I6YmQ6ZGE6YmU6YjE6OGE6\nZmM6OWE6YmE6YjU6YmM6ODM6ZTc6NWU6NDE6NmY6ZjI6NzM6OTU6NTg6MGM6ZGIw\nWQYDVR0RBFIwUIZOc3BpZmZlOi8vMTExMTExMTEtMjIyMi0zMzMzLTQ0NDQtNTU1\nNTU1NTU1NTU1LmNvbnN1bC9ucy9kZWZhdWx0L2RjL2RjMS9zdmMvd2ViMAoGCCqG\nSM49BAMCA0gAMEUCIGC3TTvvjj76KMrguVyFf4tjOqaSCRie3nmHMRNNRav7AiEA\npY0heYeK9A6iOLrzqxSerkXXQyj5e9bE4VgUnxgPU6g=\n-----END CERTIFICATE-----\n"
+                    },
+                    "privateKey": {
+                      "inlineString": "-----BEGIN EC PRIVATE KEY-----\nMHcCAQEEIMoTkpRggp3fqZzFKh82yS4LjtJI+XY+qX/7DefHFrtdoAoGCCqGSM49\nAwEHoUQDQgAEADPv1RHVNRfa2VKRAB16b6rZnEt7tuhaxCFpQXPj7M2omb0B9Fav\nq5E0ivpNtv1QnFhxtPd7d5k4e+T7SkW1TQ==\n-----END EC PRIVATE KEY-----\n"
+                    }
+                  }
+                ],
+                "validationContext": {
+                  "trustedCa": {
+                    "inlineString": "-----BEGIN CERTIFICATE-----\nMIICXDCCAgKgAwIBAgIICpZq70Z9LyUwCgYIKoZIzj0EAwIwFDESMBAGA1UEAxMJ\nVGVzdCBDQSAyMB4XDTE5MDMyMjEzNTgyNloXDTI5MDMyMjEzNTgyNlowFDESMBAG\nA1UEAxMJVGVzdCBDQSAyMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEIhywH1gx\nAsMwuF3ukAI5YL2jFxH6Usnma1HFSfVyxbXX1/uoZEYrj8yCAtdU2yoHETyd+Zx2\nThhRLP79pYegCaOCATwwggE4MA4GA1UdDwEB/wQEAwIBhjAPBgNVHRMBAf8EBTAD\nAQH/MGgGA1UdDgRhBF9kMToxMToxMTphYzoyYTpiYTo5NzpiMjozZjphYzo3Yjpi\nZDpkYTpiZTpiMTo4YTpmYzo5YTpiYTpiNTpiYzo4MzplNzo1ZTo0MTo2ZjpmMjo3\nMzo5NTo1ODowYzpkYjBqBgNVHSMEYzBhgF9kMToxMToxMTphYzoyYTpiYTo5Nzpi\nMjozZjphYzo3YjpiZDpkYTpiZTpiMTo4YTpmYzo5YTpiYTpiNTpiYzo4MzplNzo1\nZTo0MTo2ZjpmMjo3Mzo5NTo1ODowYzpkYjA/BgNVHREEODA2hjRzcGlmZmU6Ly8x\nMTExMTExMS0yMjIyLTMzMzMtNDQ0NC01NTU1NTU1NTU1NTUuY29uc3VsMAoGCCqG\nSM49BAMCA0gAMEUCICOY0i246rQHJt8o8Oya0D5PLL1FnmsQmQqIGCi31RwnAiEA\noR5f6Ku+cig2Il8T8LJujOp2/2A72QcHZA57B13y+8o=\n-----END CERTIFICATE-----\n"
+                  }
+                }
+              },
+              "requireClientCertificate": true
+            }
+          }
+        }
+      ],
+      "trafficDirection": "INBOUND"
+    }
+  ],
+  "typeUrl": "type.googleapis.com/envoy.config.listener.v3.Listener",
+  "nonce": "00000001"
+}
\ No newline at end of file
diff --git a/agent/xds/testdata/listeners/terminating-gateway-service-subsets.envoy-1-20-x.golden b/agent/xds/testdata/listeners/terminating-gateway-service-subsets.envoy-1-20-x.golden
index 2515ef21eff..7e0cd404d69 100644
--- a/agent/xds/testdata/listeners/terminating-gateway-service-subsets.envoy-1-20-x.golden
+++ b/agent/xds/testdata/listeners/terminating-gateway-service-subsets.envoy-1-20-x.golden
@@ -354,7 +354,16 @@
                   "randomSampling": {
 
                   }
-                }
+                },
+                "forwardClientCertDetails": "APPEND_FORWARD",
+                "setCurrentClientCertDetails": {
+                  "subject": true,
+                  "cert": true,
+                  "chain": true,
+                  "dns": true,
+                  "uri": true
+                },
+                "stripAnyHostPort": true
               }
             }
           ],
diff --git a/agent/xds/testdata/listeners/terminating-gateway.envoy-1-20-x.golden b/agent/xds/testdata/listeners/terminating-gateway.envoy-1-20-x.golden
index 4351d8f2162..948d8e5092d 100644
--- a/agent/xds/testdata/listeners/terminating-gateway.envoy-1-20-x.golden
+++ b/agent/xds/testdata/listeners/terminating-gateway.envoy-1-20-x.golden
@@ -169,7 +169,12 @@
                   }
                 }
               },
-              "requireClientCertificate": true
+              "requireClientCertificate": true,
+              "upgradeConfigs": [
+                {
+                  "upgradeType": "websocket"
+                }
+              ]
             }
           }
         },
diff --git a/api/config_entry.go b/api/config_entry.go
index e28c7dc1816..7853057b3f0 100644
--- a/api/config_entry.go
+++ b/api/config_entry.go
@@ -116,6 +116,9 @@ type ExposePath struct {
 	// Valid values are "http" and "http2", defaults to "http"
 	Protocol string `json:",omitempty"`
 
+	// Websocket whether websocket upgrade is supported.
+	Websocket bool `json:",omitempty"`
+
 	// ParsedFromCheck is set if this path was parsed from a registered check
 	ParsedFromCheck bool
 }
@@ -157,6 +160,8 @@ type UpstreamConfig struct {
 	// routing etc.
 	Protocol string `json:",omitempty"`
 
+	Websocket bool `json:",omitempty"`
+
 	// ConnectTimeoutMs is the number of milliseconds to timeout making a new
 	// connection to this upstream. Defaults to 5000 (5 seconds) if not set.
 	ConnectTimeoutMs int `json:",omitempty" alias:"connect_timeout_ms"`
@@ -207,6 +212,7 @@ type ServiceConfigEntry struct {
 	Name             string
 	Namespace        string                  `json:",omitempty"`
 	Protocol         string                  `json:",omitempty"`
+	Websocket        bool                    `json:",omitempty"`
 	Mode             ProxyMode               `json:",omitempty"`
 	TransparentProxy *TransparentProxyConfig `json:",omitempty" alias:"transparent_proxy"`
 	MeshGateway      MeshGatewayConfig       `json:",omitempty" alias:"mesh_gateway"`
